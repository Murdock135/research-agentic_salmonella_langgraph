from typing import Dict, Tuple, Optional
import multiprocessing
import ast
import time
from contextlib import redirect_stderr, redirect_stdout
import io

from pydantic import BaseModel
from langchain_core.tools import tool


# =========================================================================
# OUTPUT SCHEMA
# NOTE: Adopt this later into output_schemas.py
# =========================================================================

class ExecutionResult(BaseModel):
    code: str
    stdout: str
    stderr: str
    return_value: str
    success: bool
    execution_time: float
    execution_mode: str

# =========================================================================
# PERSISTENT GLOBALS FOR EXECUTION CONTEXT
# =========================================================================

_GLOBALS: Dict = {"__builtins__": __builtins__}

# =========================================================================
# CONFIGURATION FOR CODE EXECUTION
# =========================================================================\
# TODO: Use this config in the execution functions
# TODO: (FUTURE): Move this to a YAML or JSON file for easier modification
config = {
    "execution_timeout": 30,  # seconds
    "__GLOBALS": {"__builtins__": __builtins__},
    "whitelisted_stdlib": [
        "math",
        "random",
        "datetime",
        "json",
        "re",
        "itertools",
        "functools",
        "collections",
        "statistics",
        "heapq",
        "bisect",
        "time",
        "string",
    ],
    "whitelisted_external": [
        "numpy",
        "pandas",
        "scipy",
        "matplotlib",
        "seaborn",
        "plotly",
        "requests",
        "beautifulsoup4",
        "sympy",
        "statsmodels",
        "sklearn",
    ],
}


def extract_last_expr(code: str) -> Tuple[Optional[str], str]:
    """
    Check if the last line is an expression and extract it.
    Returns: (last_expression, remaining_code)
    """
    try:
        tree = ast.parse(code)
        if not tree.body:
            return None, code
        
        last_node = tree.body[-1]
        
        if isinstance(last_node, ast.Expr):
            lines = code.strip().split('\n')
            last_line = lines[-1].strip()
            rest = '\n'.join(lines[:-1]) if len(lines) > 1 else ""
            return last_line, rest
        else:
            return None, code
    except SyntaxError:
        return None, code    

def worker(
        code: str,
        globals: Dict,
        queue: multiprocessing.Queue,
) -> None:
    """
    Docstring for worker
    
    :param code: Description
    :type code: str
    :param globals: Description
    :type globals: Dict
    :param queue: Description
    :type queue: multiprocessing.Queue
    :param execution_mode: Description
    :type execution_mode: str

    How it works:
    1. Extract the last expression from the code.
    2. Redirect stdout and stderr to StringIO buffers.
    3. Execute the remaining code with exec().
    4. Evaluate the last expression with eval() if it exists.
    5. Capture outputs and return them via the queue.

    Background:
    - io.StringIO is a function that allows us to create in-memory text streams, thus letting us treat strings as file-like objects.
    - redirect_stdout and redirect_stderr are context managers that temporarily redirect the output of print statements and error messages to the specified StringIO buffers.
    - stdout is used to capture standard output, while stderr captures error messages.
    """

    result = {
        "globals": globals,
        "stdout": "",
        "stderr": "",
        "return_value": None,
        "success": False
    }

    try:
        last_expr, remaining_code = extract_last_expr(code)

        stdout_buffer = io.StringIO()
        stderr_buffer = io.StringIO()

        with redirect_stdout(stdout_buffer), redirect_stderr(stderr_buffer):
            if remaining_code:
                exec(remaining_code, globals)

            if last_expr:
                result["return_value"] = eval(last_expr, globals)

        result["stdout"] = stdout_buffer.getvalue()
        result["stderr"] = stderr_buffer.getvalue()
        result["success"] = True
    except Exception as e:
        result["stderr"] += str(e)
    finally:
        queue.put(result)

def _execute_code(
        code: str,
        globals: Dict,
        execution_mode: str,
        timeout: int = 30,
):
    """
    Args:
        code (str): The Python code to execute.
        globals (Dict): The global context for code execution.
        execution_mode (str): "isolated" or "persistent".
        timeout (int): Maximum execution time in seconds.

    Returns:
        ExecutionResult: The result of the code execution.

    How it works:
    1. Start a separate process to run the worker function.
    2. Wait for the process to complete or timeout.
    3. If timeout occurs, terminate the process and return a timeout message.
    4. If the process completes, retrieve the result from the queue and return it.

    Background:
    - multiprocessing.Process is used to create a new process that runs the worker function.
    - multiprocessing.Queue is used for inter-process communication to get results back from the worker.
    - The multiprocessing.Queue object is passed to the multiprocessing.Process so that the worker can put the results into the queue.
    - The results are retrieved from the queue using queue.get() after the process completes.
    - The execution_mode parameter determines whether the globals are updated after execution.
    - process.join(timeout) waits for the process to finish or the timeout to occur.
    - process.terminate() is called to stop the process if it exceeds the timeout.

    See Also:
    - See worker function for code execution details.
    - See ExecutionResult for output schema.
    - The worker function returns a dictionary with stdout, stderr, return_value, and success status. Thus, that is what the queue.get() retrieves.
    """

    start_time = time.time()

    queue = multiprocessing.Queue()
    process = multiprocessing.Process(
        target=worker, 
        args=(code, globals, queue, execution_mode)
        )
    
    # Start the process
    process.start()

    # Wait for the process to finish or timeout
    process.join(timeout)
    if process.is_alive():
        process.terminate()
        return ExecutionResult(
            code=code,
            stdout="",
            stderr="Execution timed out.",
            return_value="",
            success=False,
            execution_time=time.time() - start_time,
            execution_mode=execution_mode
        )
    else:
        result = queue.get()

        # If in persistent mode, update the globals
        if execution_mode == "persistent":
            globals.update(result.get("globals", {}))

        return ExecutionResult(
            code=code,
            stdout=result.get("stdout"),
            stderr=result.get("stderr"),
            return_value=str(result.get("return_value")),
            success=result.get("success"),
            execution_time=time.time() - start_time,
            execution_mode=execution_mode
        )
    
@tool
def execute_code_isolated(code: str) -> ExecutionResult:
    """
    Executes Python code in an isolated context, without maintaining state across executions.

    Args:
        code (str): The Python code to execute.
    
    Returns:
        ExecutionResult: The result of the code execution.

    How it works:
    1. Calls _execute_code. In _execute_code, globals are not updated after execution.
    2. Returns the ExecutionResult.
    """

    results: ExecutionResult = _execute_code(
        code=code,
        globals=_GLOBALS,
        execution_mode="isolated",
        timeout=30
    )
    return results

@tool
def execute_code_persistent(code: str) -> ExecutionResult:
    """
    Executes Python code in a persistent context, maintaining state across executions.
    
    Args:
        code (str): The Python code to execute.

    Returns:
        ExecutionResult: The result of the code execution.

    How it works:
    1. Calls _execute_code. In _execute_code, globals are updated after execution.
    2. Returns the ExecutionResult.
    """

    results: ExecutionResult = _execute_code(
        code=code,
        globals=_GLOBALS,
        execution_mode="persistent",
        timeout=30
    )
    return results